Split Verifier/Prover to (A,H)Verifier/Prover

==================

Pr[Sim1 : q res2 | res1=true] ~= Pr[ZK : q res2]

i.e.,

Pr[Sim1 : res1 /\ q res2] / Pr[Sim1 : res1] ~= Pr[ZK : q res2]

i.e.,

|Pr[Sim1 : res1 /\ q res2] / Pr[Sim1 : res1] - Pr[ZK : q res2]| <= eps

Final "basic proof" (assumption for the goal):

|Pr[Sim1 : res1 /\ q res2] / Pr[Sim1 : res1] - Pr[ZK : q res2]| <= eps


Goal: |Pr[ Sim(n) : res1 /\ q res2 ] - C(n) * Pr[ZK]| <= C(n) * eps, and C(n) -> 1

Derivation:

exists p,  0 <= p <= eps  =>
  Pr[Sim1 : res1 /\ q res2]  = Pr[Sim1 : res1]  * (Pr[ZK : q res2] + p) \/
  Pr[Sim1 : res1 /\ q res2]  = Pr[Sim1 : res1]  * (Pr[ZK : q res2] - p) 

=> N iterations and success and i-th:

  Pr[Sim(n) : counter = i /\ res1 /\ q res2]
    = (Pr[Sim1 : !res1]^i  * Pr[Sim1 : res1]) * (Pr[ZK : q res2] + p) \/
  Pr[Sim(n) : counter = i /\ res1 /\ q res2]
    = (Pr[Sim1 : !res1]^i  * Pr[Sim1 : res1]) * (Pr[ZK : q res2] - p)


|Pr[ Sim(n) ] - C(n) * Pr[ZK]| = C(n) * p, where C(n) has limit at 1

=> |Pr[ Sim(n) ] - C(n) * Pr[ZK]| <= C(n) * eps, where C(n) has limit at 1

===============

use sum-binding for 2 challenges:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2 * Extractor  ≥ P_1 + P_2 - 1. (already proved)
=>
2 * Extractor ≥ P_$ * 2 - 1.
=>
Extractor >= (P_$ * 2 - 1)/2
=>
Pr [ Extractor : succ ] >= P_$ - 1/2


more than two challenges:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
1/ Show:     
  Pr[ init(); c1 <$ d; r1 <- run1(c1); 
      c2 <$ d; r2 <- run2(c2) 
  : AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2] >= P_$(P_$ - 1/c) (some formula)

2/ In computational case:

Assume:
  Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2  /\ ~ SuccessfulExtraction] <= negl  
  (by comp SS assumption, using that r1,r2,c1,c2 come from efficient algorithm)

2.1/ Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2 ]
   = Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2 /\ SuccExtract ]
    + Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2 /\ !SuccExtract ]
   ≤ Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2 /\ SuccExtract ]
     + negl
 ⇒ (some formula) ≤ 
      Pr [ AcceptingRun r1 /\ AcceptingRn r2 /\ c1!=c2 /\ SuccExtract ] + negl
 ⇒ Pr[ SuccessfulExtraction ] >= (some formula) - negl


2.2/ Assume no witness exists 
  ⇒ Pr[SuccessfulExtraction] = 0 
  ⇒ 0 ≥ (some formula) - negl 
  ⇒ negl ≥ (some formula)
  ⇒ negl ≥ (P_$^2 - P_$/c)
  ⇒ negl + P_$/c ≥ P_$^2
  ⇒ sqrt (negl + P_$/c) ≥ P_$
  ⇒ sqrt (negl + 1/c) ≥ P_$
   
3/ In non-computation case: 

 Pr[ SuccessfulExtraction ] >= (some formula) (from 2.1 where negl = 0)

==================================

ExtractWit needs n transcripts (more complicated)

run1(c1)
run2(c2)
Pr[success] = e^2

Naive n-transcript:
for i=1..n: run_i(c_i)
Pr[success] = e^n

Better n-transcript 1:
for i=1..bound: ci<-$;  run_i(c_i)
success if n out of the bound iterations succeeded
 


Better n-transcript 2:
for i=1..n:
  try bound times: ci<-$; run_i(c_i) till success
Pr[success] = (Pr[inner success])^n


Better n-transcript 4: (Special case: n out of n, hence n not too big)
for i=1..n:
  ci<-n; bound times: run_i(c_i)

(Proof for this: Assume (for fixed com): Pr[PV] >= (n-1)/n + delta.
avg_{i<n} Pr[PV with i] >= (n-1)/n + delta.
==> Pr[PV with i] >= delta. (for all i)
bound := Omega(1/delta).
Pr[bound time: run(ci:=i)] >= 1-eps. (for small eps)
Then: overall success >= 1-n*eps ~= 1.)



Better n-transcript 5: (Possibly equal to one of the ones above)
for i=1..n:
  bound times: ci<-$; run_i(c_i)  (VARIANT: c<-{fresh ones})

{PV := ci<-$; run_i(c_i)}

(Proof for this:

Pr[PV, c notin M] >= Pr[PV] - M/C.

Pr[c<-$, run_i(c_i) succeed and fresh] >= Pr[PV] - |M|/C. (if in M-th outer round)
This is >= delta if Pr[PV] >= (n-1)/C + delta.
Pr[M-th outer round succeeds] >= 1-eps (if bound is Omega(1/delta))
Pr[all rounds succeed] >= 1-n*eps.)






Better n-transcript 3: (useful for expected poly case)
run1(c1)
the rest as in 2/3 (possibly without bound)

===========================

rename: prob type to stmnt

===========================

M(Correct(P,V)) == repeated correctness game
Correct(M(P),M(V)) == correctness game with repeated prover/verifier


====== DERIV _ inefficient ======

Define module KE which rewinds the prover
and challenges it with both bits then do the followig analysis

Pr[ Run2 ] >= Pr[ Run1 ]^2
<=>
Pr[ Run2: c = c' ] + Pr[ Run2: c <> c' ] >= Pr[ Run1 ]^2
<=>
Pr[ Run2: c <> c' ] >= Pr[ Run1 ]^2 - Pr[ Run2: c = c' ]
  {Pr[ Run2: c = c' ] <= 1/2}
<=>
Pr[ Run2: c <> c' ] >= Pr[ Run1 ]^2 - 1/2

Hence,

 Pr[ Run1 ] <= sqrt (Pr[ Run2: c <> c' ] + 1/2) (~ 0.7)

Assuming that Pr[ Run2: c <> c' ] is negligible we can iterate Run1
to get arbitrary low probability.


================

To look at:  blums hamiltonian cycle

================


1/ EagerWhileROM <-> LazyROM [*exists in stdlib AND ises "eager tactics" *]
2/ Can use "kol" to sow EagerWhileROM <-> EagerPickFunctionROM

