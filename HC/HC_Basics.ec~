pragma Goals:printall.
require import AllCore DBool Bool List Distr Int Aux DJoin.

require import Permutation.

type sbits.
type commitment, opening.

op Com  : bool -> (commitment * opening) distr.
op Ver : bool * (commitment * opening)  -> bool.

axiom Com_sound : forall (x : bool * (commitment * opening)), 
  x.`2 \in Com x.`1 => Ver x.


type graph = bool list list.

type hc_prob = (int * graph).
type hc_wit  = int list.
type hc_com  = commitment list.
type hc_resp = (permutation * (opening list) , hc_wit * (opening list)) sum.

module type Dist = {
   proc run(s : sbits) : bool
}.

require ZK_General.
clone import ZK_General as ZK_defs with type prob  = hc_prob,
                                        type wit   = hc_wit,
                                        type chal  = bool,
                                        type com   = hc_com,
                                        type resp  = hc_resp,
                                        type sbits = sbits.


module ZKP(P : Prover, V : Verifier) = {
  proc run(Ny : hc_prob, w : hc_wit, b : bool) = {
    var c,r;
    c <- P.commit(Ny,w);
    r <- P.response(b);
    return (c,r);
  }
}.


module ZKD(P : Prover, V : Verifier, D : Dist) = {
  proc main(Ny : prob, w : wit) = {
    var c,b,r,result,rb;
    c <- P.commit(Ny,w);
    b <- V.challenge(Ny,c);
    r <- P.response(b);
    result <- V.summitup(c,r);
    rb <- D.run(result);
    return rb;
  }
}.

require Djoinmap.
clone import Djoinmap as DJMM with type a <- bool, 
                                   type b <- (commitment * opening),
                                   op   d <- Com.
                                        


op compl_graph     : int -> graph.
op compl_graph_cyc : int -> int list = range 0.


op IsHC : hc_prob * hc_wit -> bool. 
op HasHC (Ny : hc_prob) = exists w, IsHC (Ny, w).

axiom ishc_prop1 a : IsHC a =>
 (fst (fst a)) = size (snd a) 
    /\ size (flatten (snd (fst a))) 
         = (fst (fst a)) * (fst (fst a)).


axiom ishc_prop2 a : IsHC a =>
  0 < (fst (fst a)).

axiom ishc_prop4 a : IsHC a =>
  uniq a.`2 /\ (  forall (i : int), i \in a.`2 => 0 <= i && i < a.`1.`1).
