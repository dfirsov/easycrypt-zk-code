# Formalization Caveats

## Initialization

One important design decision that arose in the formalization was how the initial state of the various adversarial algorithms (e.g., malicious verifier, malicious prover) is instantiated. We identified several options: 
 - **a.** Adversarial algorithms get a special procedure called `init()` whose task is to initialize their state. 
 -  **b.** Adversarial algorithms get a special procedure called `init()`, and additionally this procedure is constrained to initialize all variables of the adversary before reading them. (No dependence on the initial memory `&m`. EasyCrypt's module type system allows us to enforce this by adding a `*` to the procedure declaration.)
 - **c.**  Adversarial algorithms get no initialization procedure. 
 - **d.** Any of the three options above, and the adversary additionally get an all-quantified auxiliary input as an argument. 

Different choices have different subtle consequences both on the cryptographic interpretation as well as on the details of the formal proofs.

Cryptographically, giving an additional all-quantified argument (known as auxiliary input) gives us a definition called *non-uniform zero-knowledge*. In contrast, without auxiliary input, we get *uniform zero-knowledge*. It is known that to get sequential composition of zero-knowledge proofs, we need to use non-uniform zero-knowledge. So which of the above design options lead to a non-uniform definition? Obviously, option **d.** has an auxiliary input. However, options **a.** and **c.** also have one, this is just implicit in the way how EasyCrypt works: Unless we explicitly enforce procedures that do not look at their initial state (as in **b.**), all procedures can access the content of their global variables in the initial memory `&m`. And all our theorems are of the form `forall &m, ...`, which means that the adversary effectively gets an auxiliary input implicitly. Only option **b.** (when not combined with **d.**) models uniform zero-knowledge. We believe that it is important to stress this point explicitly because EasyCrypt's handling of global variables makes it easy to overlook this implicit dependency.

In the formal setting it is easier to work with games without explicit state initialization. For example, in our development we defined the `Soundness(P,HV)` game which encodes the three message exchange between the malicious prover `P` and the honest verifier `|HV|`. Later, we defined the module `SoundnessAmp` which sequentially iterates the `Soundness` game $n$ times.  Then we proved that $n$-time sequential composition of sigma-protocols exponentially reduces the soundness-error to $\delta^n$. The proof is based on the premise that for any initial state the soundness-error for the `Soundness` game is below `deltoid`.  However, if we add state initialization of to the malicious prover in the |Soundness| game, then it is meaningless to keep `SoundnessAmp` defined as an $n$-time iteration of the `Soundness` game. Instead, we will need to add an explicit initialization of the malicious prover before the while-loop and the body of the while-loop must implement the three message exchange. This means that the proof of amplified soundness (similar to lemma `soundness_seq`) will become more complicated due to the fact that we split the prover into an iterated and a non-iterated part (e.g., we will need to use "averaging'' technique and Jensen's inequality).

In our formalization we used the **c.** approach as it results in simpler proofs. However, we recognize that in some situations the state initialization of adversaries is necessary. To make our results relevant for these situations, we provide generic lemmas for removing/adding init-procedures in security claims (not limited to the zero-knowledge setting). We proved a generic lemma which states that for any algorithm `A` if there exists an $\epsilon$ which   is an upper/lower bound for the probability of the "initialize-then-single-run'' program then there exists a memory `&n` (initial state) so that running `A` on `&n` (without explicit initialization) results in the success-probability also bounded from above/below by $\epsilon$. We also prove an analogous one for indistinguishability.

## Disjointness of Module-Variables
In the cryptographic setting, when we have a definition such as zero-knowledge, and we say "there is a simulator $S$ such that for all verifiers $V$ and all distinguishers $D$, ...'', we usually implicitly mean that those three algorithms $S,V,D$ have disjoint state. That is, we expect that they do not access each other's variables unless we would explicitly specify that they do so. When, e.g., the simulator runs a simulated $V$ internally, we then can think of that $V$ as a *copy* of the original $V$ inside the simulator. The simulator still has no access to the variables of the ``original'' $V$. In the case of the simulator and the verifier, this distinction is of lesser importance because in the games making up the definition of zero-knowledge, $S$ and $V$ never run in the same game, so they cannot influence each other anyway. However, the distinguisher and the verifier, for example, run at the same time. So it can make a difference whether they can read/write each other's variables or not. The implicit assumption in the cryptographic setting is again that they do not. And if the distinguisher~$D$ needs, e.g., to simulate internally a copy of the verifier~$V$ (e.g., in the sequential composition proof), it is understood that this is a completely separate instance of~$V$ whose variables are part of the state of~$D$.

Translating this to the EasyCrypt setting, the obvious solution would be to restrict the global variables of the various algorithms analogously. That is, we quantify over `S{-V,-D}`, `D{-S,-V}`, `V{-S,-D}`, which EasyCrypt understands to mean that their global variables are disjoint. Doing so, however, we encountered a problem that has no counterpart in the cryptographic pen-and-paper proofs: In the sequential composition proof for zero-knowledge, we needed to construct a distinguisher $D$ that internally simulates a copy of $V$. However, EasyCrypt has no support for "copying'' a module. Instead, if $D$ wants to depend on the behavior of $V$, $D$ has to access the module $V$ directly, and this access can modify the state of $V$. We can, if we want, undo this modification using the `setState` and `getState` procedures. While this will make sure that semantically $D$ does not change the state of $V$, it does not change which variables EasyCrypt *thinks* that $D$ accesses because this is computed syntactically. In order to be able to prove sequential composition, we thus needed to relax the condition on the variables of $D$ and $V$, and allow the distinguisher and verifier to have common global variables. (I.e., declaring `D{-S}`, `V{-S}`.)

Since this departs from what the cryptographer expects, it is important to check whether this changes the meaning of the zero-knowledge definition. Fortunately, in the specific case of zero-knowledge, it does not, because the distinguisher runs after the verifier has already terminated, so their code does not "get into each other's way''. Also, the goal of the verifier is to output as much information as possible about what it learned, so we can assume without loss of generality that the verifier tells everything to the distinguisher anyway. So the fact that the distinguisher can read the verifier's state does not give any information to the distinguisher that it should not have.

So in the present situation, all is fine if we relax the disjointness conditions. However, in other contexts (maybe some proof where a distinguishing entity runs concurrently with an adversary such as in the Universal Composability framework), it might not be possibly to allow different modules to share state for technical reasons.

We believe that it would be a very useful feature if EasyCrypt would allow us to "copy'' modules to facilitate proofs where one program simulates another.

