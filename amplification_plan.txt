


 module SoundnessAmp(P: MaliciousProver, V: HonestVerifier) = { 
   proc run(statement:statement, witness:witness, N : int) = { (* or N is a constant *) 
     var commit, challenge, response, accept; 
     accept <- true; 
     for (i=0 to N) { 
       Soundness(P,V).run();
       accept = accept /\ r 
     } 
     return accept; 
   } 
 }. 
 - 


module CompletenessAmp(P: HonestProver, V: HonestVerifier) = { 
  proc run(statement:statement, witness:witness, N : int) = { (* or N is a constant *) 
    var commit, challenge, response, accept; 
    accept <- true; 
    for (i=0 to N) {  
      accept = accept /\ Completeness(P,V).run(); 
    } 
    return accept; 
  } 
}. 



module ZKRealAmp(P: HonestProver, V: MaliciousVerifier, D: ZKDistinguisher) = {
  proc run(statement: statement, witness: witness) = {
    var commit, challenge, response, summary, guess;

     while(i=0 to N){
       commit <@ P.commitment(statement, witness);
       challenge <@ V.challenge(statement, commit, aux);
       response <@ P.response(challenge);
       summary <@ V.summitup(statement, response);
     }

    guess <@ D.guess(statement, witness, summary);
    return guess;
  }
}.

module SimAmp(S: Simulator) = { 
  proc simulate(statement, N,n) = { 
  var summary; 
    while(i=1 to N) { 
      summary <@ S.simulate(statement, n); 
      (* Sim1 rewinds itself therefore this must be undone *) 
    } 
    return summary; 
  }; 
}


Goal: If ZKReal ~ ZKIdeal(S), then ZKRealAmp ~ ZKIdel(SimAmp(S))
ZKHybrid(i) := First i iteration: ZKReal, remaining: S
Claim 1: ZKRealAmp = ZKHybrid(N)
Claim 2: ZKIdeal(SimAmp(S)) = ZKHybrid(0)
Claim 3: ZKHybrid(i+1) ~(eps) ZKHybrid(i)  for uniformly random i  [by reduction]
Claim 4: ZKHybrid(i+1) ~(eps_i) ZKHybrid(i)   with eps = sum eps_i / N
Induction: ZKRealAmp ~(sum eps_i) ZKIdeal(SimAmp(S))
Thus ZKRealAmp ~(N eps)  ZKIdeal(SimAmp(S))


q -> N
Ob -> module { proc left = { ZKReal }, proc right = { S } }
L(Ob) -> module { proc f = { Ob.left } }
R(Ob) -> module { proc f = { Ob.right } }
HybGame -> i <$ uniform; A(Ob*) where Ob* = Ob.left for the first i calls, Ob.right afterwards
A(Ob*) -> while () { Ob*.call }; D(last-result)
Ln(Ob,A) -> A(Ob.left)
Rn(Ob,A) -> A(Ob.right)

Then Ln = ZKRealAmp;  Rn = ZKIdeal(SimAmp(S))
And HybGame(..L) = bunch of ZKReal, ZKReal, bunch of ZKIdeal
And HybGame(..R) = bunch of ZKReal, ZKIdeal, bunch of ZKIdeal

D' = run bunch of ZKIdeal; run D

[If we add .init to all adversaries:  V' = V.commit/response/summitup, init={V.init; bunch}]


Pr[HybGame L @ m ] - Pr[HybGame R @ m]
= Pr[bunch, ZKReal(V), D' @ m] - Pr[bunch, ZKIdeal(V), D' @ m]
{exists n,}
<=   ( Pr[ZKReal, D' @ n] - Pr[ZKIdeal, D' @ n] )


  lemma Hybrid_restr &m (p:glob A -> glob Ob -> int -> outputA -> bool):
        Pr[HybGame(A,Ob,L(Ob)).main() @ &m : p (glob A) (glob Ob) HybOrcl.l res]
      - Pr[HybGame(A,Ob,R(Ob)).main() @ &m : p (glob A) (glob Ob) HybOrcl.l res]
    = 1%r/q%r * (  Pr[Ln(Ob,A).main() @ &m : p (glob A) (glob Ob) Count.c res]
                 - Pr[Rn(Ob,A).main() @ &m : p (glob A) (glob Ob) Count.c res]).





abstract theory Jensen.
type argI, argA, argB
module type M = { proc init(...) : unit  proc a(arg:argA) : bool  proc b(...) : bool }
module WithInit = { proc runA = { init(...); a(...); }  proc runB = {... } }
lemma argI argA argB M &m:
  (forall &m, Pr[res : M.a(argA) @ &m] <= f(Pr[res : M.b(argB) @ &m]))
  =>
  Pr[res : WithInit(M).runA &m] <= f(Pr[res : WithInit(M).runB @ &m])
end theory

module M = {
proc init = bunch
proc a = ZKReal
proc b = ZKIdeal
}
lemma WithInit(M).runA = HybGame(L); WithInit(M).runB = HybGame(R)












































module ExtractorAmp(P : MProver3N) = {
  proc extract(p : statement) = {
    var w;
   while( i = 0 to N /\ ! soundness_relation p w) {
    PX := something(P)
    w <- Extractor(PX : MProver3).extract(p)
   }
   return w;
}

}



    lemma statistical_PoK &m p aux:
      (forall &m, Pr[Extractor(P).extract(p) @ &m : soundness_relation p res] >= deltoid)

   =>  Pr[ExtractorAmp(P).extract(p) @ &m : soundness_relation p res] >= f deltoid 









