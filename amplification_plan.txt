

   (* init makes things harder *) 
 module SoundnessAmp(P: MaliciousProver, V: HonestVerifier) = { (* consider init before the first iteration which  *) 
   proc run(statement:statement, witness:witness, N : int) = { (* or N is a constant *) 
     var commit, challenge, response, accept; 
     accept <- true; 
     P.init(); 
     for (i=0 to N) { 
         copy Soundness without init 
       accept = accept /\ r 
     } 
     return accept; 
   } 
 }. 
 - 


module CompletenessAmp(P: HonestProver, V: HonestVerifier) = { 
  proc run(statement:statement, witness:witness, N : int) = { (* or N is a constant *) 
    var commit, challenge, response, accept; 
    accept <- true; 
    for (i=0 to N) {  
      accept = accept /\ Completeness(P,V).run(); 
    } 
    return accept; 
  } 
}. 



module ZKRealAmp(P: HonestProver, V: MaliciousVerifier, D: ZKDistinguisher) = {
  proc run(statement: statement, witness: witness, aux: auxiliary_input) = {
    var commit, challenge, response, summary, guess;
     V.init();

     while(){
       commit <@ P.commitment(statement, witness);
       challenge <@ V.challenge(statement, commit, aux);
       response <@ P.response(challenge);
       summary <@ V.summitup(statement, response);
     }

    guess <@ D.guess(statement, witness, aux, summary);
    return guess;
  }
}.





module SimAmp(S: Simulator) = { 
  proc simulate(statement, n) = { 
  var summary; 
    for (i=1..N) { 
      summary <@ S.simulate(statement, n); 
    } 
    return summary; 
    }; 
}


Goal: If ZKReal ~ ZKIdeal(S), then ZKRealAmp ~ ZKIdel(SimAmp(S))

ZKHybrid(i) := First i iteration: ZKReal, remaining: S

Claim 1: ZKRealAmp = ZKHybrid(N)

Claim 2: ZKIdeal(SimAmp(S)) = ZKHybrid(0)

Claim 3: ZKHybrid(i+1) ~(eps) ZKHybrid(i)  for uniformly random i  [by reduction]

Claim 4: ZKHybrid(i+1) ~(eps_i) ZKHybrid(i)   with eps = sum eps_i / N

Induction: ZKRealAmp ~(sum eps_i) ZKIdeal(SimAmp(S))

Thus ZKRealAmp ~(N eps)  ZKIdeal(SimAmp(S))


q -> N
Ob -> module { proc left = { ZKReal }, proc right = { S } }
L(Ob) -> module { proc f = { Ob.left } }
R(Ob) -> module { proc f = { Ob.right } }
HybGame -> i <$ uniform; A(Ob*) where Ob* = Ob.left for the first i calls, Ob.right afterwards
A(Ob*) -> while () { Ob*.call }; D(last-result)
Ln(Ob,A) -> A(Ob.left)
Rn(Ob,A) -> A(Ob.right)

Then Ln = ZKRealAmp;  Rn = ZKIdeal(SimAmp(S))
And HybGame(..L) = bunch of ZKReal, ZKReal, bunch of ZKIdeal
And HybGame(..R) = bunch of ZKReal, ZKIdeal, bunch of ZKIdeal

D' = run bunch of ZKIdeal; run D

[If we add .init to all adversaries:  V' = V.commit/response/summitup, init={V.init; bunch}]


Pr[HybGame L @ m ] - Pr[HybGame R @ m]
= Pr[bunch, ZKReal(V), D' @ m] - Pr[bunch, ZKIdeal(V), D' @ m]
<= max-n ( Pr[ZKReal, D' @ n] - Pr[ZKIdeal, D' @ n] )
[Or: if we add .init: = Pr[ZKReal(V'), D' @ n] - Pr[ZKIdea(V')l, D' @ n]

soundness
  init
  ...

soundnessAmp
    init
  while

    ..


  lemma Hybrid_restr &m (p:glob A -> glob Ob -> int -> outputA -> bool):
        Pr[HybGame(A,Ob,L(Ob)).main() @ &m : p (glob A) (glob Ob) HybOrcl.l res]
      - Pr[HybGame(A,Ob,R(Ob)).main() @ &m : p (glob A) (glob Ob) HybOrcl.l res]
    = 1%r/q%r * (  Pr[Ln(Ob,A).main() @ &m : p (glob A) (glob Ob) Count.c res]
                 - Pr[Rn(Ob,A).main() @ &m : p (glob A) (glob Ob) Count.c res]).

abstract theory Jensen.

type argI, argA, argB

module type M = { proc init(...) : unit  proc a(arg:argA) : bool  proc b(...) : bool }

module WithInit = { proc runA = { init(...); a(...); }  proc runB = {... } }

lemma argI argA argB M &m:
  (forall &m, Pr[res : M.a(argA) @ &m] <= f(Pr[res : M.b(argB) @ &m]))
  =>
  Pr[res : WithInit(M).runA &m] <= f(Pr[res : WithInit(M).runB @ &m])

end theory


module M = {
proc init = bunch
proc a = ZKReal
proc b = ZKIdeal
}

lemma WithInit(M).runA = HybGame(L); WithInit(M).runB = HybGame(R)
































































